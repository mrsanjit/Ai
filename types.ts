export type DataRow = Record<string, any>;

export interface MetricDefinition {
  column: string;
  operation: 'SUM' | 'COUNT' | 'AVG' | 'MIN' | 'MAX' | 'COUNT_DISTINCT' | 'NONE'; // NONE for direct value or pre-aggregated
  displayName: string;
}

export interface DimensionDefinition {
  column: string;
  displayName: string;
}

export interface BaseElementSpec {
  id: string;
  title: string;
  dataSourceQuery?: string; // Optional SQL query to source data for this element
  interpretation?: string; // Optional AI interpretation of what this element shows
}

export interface KPIDescriptor extends BaseElementSpec {
  type: 'KPI';
  metric: MetricDefinition;
  valuePrefix?: string;
  valueSuffix?: string;
}

export interface ChartDescriptor extends BaseElementSpec {
  type: 'BarChart' | 'PieChart' | 'LineChart' | 'Table' | 'ScatterPlot' | 'AreaChart' | 'Histogram' | 'MapChart'; // Added MapChart and Histogram
  dimension?: DimensionDefinition; // Optional for Table, ScatterPlot (if color-coded by category), Histogram. Required for others.
  metrics: MetricDefinition[]; // For Table: columns. ScatterPlot: X, Y axes. Histogram: single metric.
}

export type DashboardElementSpec = KPIDescriptor | ChartDescriptor;

export interface GeminiDashboardResponse {
  title?: string; // Optional title for the whole dashboard
  dashboardStory?: string; // Optional overall insight or story from the AI
  themeSuggestion?: string; // Optional theme suggestion (e.g., "ocean_breeze")
  generatedQuery?: string; // Optional SQL query generated by AI from natural language
  elements: DashboardElementSpec[];
}

// Data structure for processed data ready for charts
export interface ProcessedChartData {
  data: any[];
  dimensionKey?: string; 
  metricKeys: string[]; 
  chartType: ChartDescriptor['type'];
  forecastExplanation?: string; // Optional explanation for a forecast
  // For ScatterPlot, metricKeys[0] is X, metricKeys[1] is Y. dimensionKey is for categorical coloring.
  // For Histogram, dimensionKey is 'binRange', metricKeys[0] is 'count'.
  // For MapChart, metricKeys[0] is lat, [1] is lon, [2] is value. dimensionKey is label.
}

export interface ProcessedKPIData {
  value: number | string;
  title: string;
  prefix?: string;
  suffix?: string;
}

export type ProcessedElementData = ProcessedChartData | ProcessedKPIData;

export interface FileData {
  name: string;
  columns: string[];
  rows: DataRow[];
}

// Filter Types
export type FilterableColumnType = 'categorical' | 'numerical'; // Add 'date' in future

export interface FilterConfig {
  column: string;
  type: FilterableColumnType;
  options?: string[]; // For categorical
  min?: number;       // For numerical (original min in data)
  max?: number;       // For numerical (original max in data)
}

export interface ActiveFilters {
  [columnName: string]: string[] | { min?: number | string; max?: number | string }; // string for min/max to allow empty input
}

// Anomaly Analysis Types
export interface Anomaly {
  description: string;
  potentialExplanations: string[];
  dataPoint?: string | number; // The dimension value or point where anomaly occurs
}

export interface AnomalyInsightResponse {
  analysisTitle?: string; // e.g., "Anomaly Analysis for Sales Over Time"
  anomalies: Anomaly[];
  summary?: string; // Overall summary from AI if any
  markdownContent?: string; // For direct rendering of AI's markdown
}

// Data Profiling Types
export interface ColumnProfile {
  columnName: string;
  inferredType: string; // e.g., "Numerical", "Categorical", "Date", "Text", "Boolean", "Mixed"
  missingPercentage: number; // 0-100
  uniqueValues?: number; // Cardinality, if applicable/calculable
  valueRange?: [number | string, number | string]; // Min/max for numerical/date, or sample values for categorical
  notes?: string; // e.g., "High cardinality", "Possible mixed types", "Contains outliers"
}

export interface DataProfile {
  overallSummary: string; // AI's overall assessment of the data quality/structure
  columns: ColumnProfile[];
}

export interface AIDataProfileResponse {
  profile: DataProfile;
}

// Drill Down Filter State
export interface DrillDownFilterState {
  column: string;
  value: any;
}

// Automated Insights Types
export interface AIAutomatedInsightsResponse {
  suggestedPrompts: string[];
}

// For Save/Share state
export interface AppState {
    fileData: FileData;
    dashboardData: GeminiDashboardResponse;
    activeFilters: ActiveFilters;
    drillDownFilter: DrillDownFilterState | null;
    selectedTheme: string;
    currentPrompt: string;
    promptHistory: string[];
}

// Forecasting types
export interface AIForecastResponse {
  forecastedData: DataRow[];
  forecastExplanation: string;
}